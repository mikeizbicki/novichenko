from project import app
import time
from sqlalchemy.sql import text
from flask import Flask, send_from_directory, g, request
import flask
import functools
import inspect
import itertools


def route_get(route):
    def decorator(f):
        @functools.wraps(f)
        def wrapper():
            signature = inspect.signature(f)
            kwargs = {}
            for parameter in signature.parameters.values():
                #import logging
                #logging.warning("parameter.name="+str(parameter.name))
                #logging.warning("rrr"+str(request.args.get(parameter.name)))
                kwargs[parameter.name] = request.args.get(parameter.name, parameter.default)
            return f(**kwargs)
        wrapper = app.route(route)(wrapper)
        return wrapper
    return decorator


def render_template(name, **kwargs):
    '''
    like the flask render_template function, but also passes the debug information generated by calls to the do_query function
    '''

    # compute total time in debug_timers
    total_debug_timers = 0
    for timer in g.debug_timers:
        total_debug_timers += timer['runtime']
    g.debug_timers.append({
        'name': '[total]',
        'runtime': total_debug_timers,
        })

    # call render_template with debug information added
    return flask.render_template(
        name,
        queries=g.queries,
        debug_timers=g.debug_timers,
        **kwargs
        )


def do_query(name, sql, binds, explain_mode='explain'):
    '''
    performs a query with the database and records debug information that will be stored for later
    '''
    with g.connection.begin():
        start = time.time()
        res = list(g.connection.execute(text(sql), binds))
        if explain_mode == 'explain':
            explain = '\n'.join(map(lambda x:x[0], g.connection.execute(text('explain '+sql), binds)))
        elif explain_mode == 'explain analyze':
            explain = '\n'.join(map(lambda x:x[0], g.connection.execute(text('explain (buffers, analyze)'+sql), binds)))
        else:
            explain = ''
        stop = time.time()
        g.queries.append({
            'name': name,
            'sql': sql,
            'binds': binds,
            'runtime': stop-start,
            'explain': str(explain),
            })
        return list(res)


class debug_timer:
    '''
    time code inside a with block
    '''
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        self.start = time.time()

    def __exit__(self, type, value, traceback):
        g.debug_timers.append({
            'name': self.name,
            'runtime': time.time() - self.start,
            })



