{% extends "base.html" %}



{% block header %}
<header class=grid>
<div class="header logo">
<img src='/static/en-chajda.png' width=120px height=30px>
</div>
<div class="header search box">
<form id=form_search onsubmit='load_all_data(); return false;'>
    <input type=text name=query />
    <button type="submit"><i class="fa fa-search"></i></button>
    <select name="lang" id="lang">
      <option value="en" selected>en</option>
      <option value="es" >es</option>
    </select>
</form>
</div>
</header>
{% endblock %}




{% block content %}
<aside id=aside_xy style='grid-row: 1'>
    <h3>Mentions Options</h3>
    <ul>
        <li>axis
            <select name="mentions_axis" id="mentions_axis" form=form_search>>
              <option value="host"            >host</option>
              <option value="hostpath"selected>hostpath</option>
            </select>
        </li>
        <li>granularity
            <select name="granularity" id="granularity" form=form_search>
              <option value="year"  selected>year</option>
              <option value="month"         >month</option>
              <option value="day"           >day</option>
            </select>
        </li>
    </ul>
</aside>
<aside id=aside_x2y2 style='grid-row:2'>
    <h3>Projection Options</h3>
    <ul>
        <li>axis
            <select name=projection_axis id=projection_axis form=form_search>
            </select>
            <br>
            pos words <input id=pos_words name=pos_words form=form_search readonly value="{{pos_words}}">
            <br>
            neg words <input id=neg_words name=neg_words form=form_search readonly value="{{neg_words}}">
            <br>
            <a href='/wordcloud?pos_words={{pos_words}}&neg_words={{neg_words}}&dim=25'>visualize projection</a>
            <br>
            <br>
            <script>
                var axis_dictionary = {
                    'anger': ['angry agitated', 'calm serene'],
                    'erotic': ['erotic sexy sensual', 'unerotic polite propper'],
                    'gender': ['female mother queen she', 'male father king he'],
                    'happiness': ['sad misery dissatisfaction bore', 'happy joy pleasure delight'],
                    'intelligence': ['intelligent', 'stupid'],
                    'life': ['alive active awake living', 'dead inactive asleep dying'],
                    'freedom': ['oppression', 'freedom'],
                    'scary': ['relaxing unafraid comfort','scary afraid fear'], 
                    'sentiment': ['positive good better best', 'negative bad worse worst'], 
                    'success': ['successful', 'failed'],
                    'threat': ['safety peace friend ally', 'danger war menace enemy'],
                    'truth': ['truth', 'lie'],
                    'war': ['peace', 'war'],
                    'wealth': ['wealth affluence rich asset', 'debt poverty poor liability'],
                };
                projection_axis = getParameterByName('projection_axis');
                select = document.getElementById('projection_axis')
                for (key in axis_dictionary) {
                    option = document.createElement("option");
                    option.textContent = key;
                    option.value = key;
                    select.add(option);
                }
                function set_projection_axis(axis) {
                    document.getElementById('projection_axis').value = axis;
                    document.getElementById('pos_words').value = axis_dictionary[axis][0];
                    document.getElementById('neg_words').value = axis_dictionary[axis][1];
                }
                set_projection_axis('sentiment');
                function projection_axis_change(e) {
                    set_projection_axis(e.currentTarget.value);
                    load_all_data();
                }
                document.getElementById('projection_axis').addEventListener('change', projection_axis_change);
            </script>
        </li>
        <li>
            <input form=form_search type="checkbox" id="rm_vh_data" name="rm_vh_data" value="True" checked><label for="rm_vh_data">rm_vh_data</label><br>
            <input form=form_search type="checkbox" id="rm_vh_hardcoded" name="rm_vh_hardcoded" value="True" checked><label for="rm_vh_hardcoded">rm_vh_hardcoded</label><br>
        </li>
        <li>window size 
            <br>
            <input type="range"  id="window_size_range" min="1" max="24" value="1" oninput="set_window_size(this.value)" />
            <br>
            <input type="number" id="window_size_number" min="1" max="24" value="1" oninput="set_window_size(this.value)" />
            <script>
            function set_window_size(window_size_new) {
                console.log('set_window_size()');
                window_size = window_size_new;
                document.getElementById('window_size_range').value = window_size;
                document.getElementById('window_size_number').value = window_size;
                plotly_redraw();
            }
            </script>
        </li>
    </ul>
</aside>


<div id=plotly style="grid-row-start:1; grid-row-end: 3;"></div>




<aside style="grid-row:3">
    <h3>Document Options</h3>
Order by
<select name="orderby" id="orderby">
  <option value="none"      {%if orderby=="none"     %}selected{%endif%}>none</option>
  <option value="time_desc" {%if orderby=="time_desc"%}selected{%endif%}>publication date (descending)</option>
  <option value="time_asc"  {%if orderby=="time_asc" %}selected{%endif%}>publication date (ascending)</option>
  <option value="rank"      {%if orderby=="rank"     %}selected{%endif%}>relevance</option>
</select>
</aside>

<div style='display:grid; grid-column:2; grid-row:3'>

<h2>Documents</h2>

<div id=docs>
</div>
</div>

<script>
var window_size = 1;
var count_data = null;
var projection_data = null;
var docs_data = [];

////////////////////////////////////////////////////////////////////////////////
// load data
////////////////////////////////////////////////////////////////////////////////

function load_all_data() {
    load_count();
    load_projection();
    load_docs();
}

function load_projection() {
    projection_data = null;
    plotly_redraw();

    const xhttp = new XMLHttpRequest();
    xhttp.onload = function() {
        //projection_data = JSON.parse(this.responseText);
        projection_data = add_randoms(JSON.parse(this.responseText));
        plotly_redraw();
    }
    url = build_url_from_form_entries('/json/projection');
    console.log('load_projection url='+url);
    xhttp.open("GET", url);
    xhttp.send();
}


function load_count() {
    count_data = null;
    plotly_redraw();

    const xhttp = new XMLHttpRequest();
    xhttp.onload = function() {
        count_data = JSON.parse(this.responseText);
        plotly_redraw();
    }
    url = build_url_from_form_entries('/json/count');
    console.log('load_count url='+url);
    xhttp.open("GET", url);
    xhttp.send();
}

function load_docs() {
    docs_data = [];
    draw_docs();

    const xhttp = new XMLHttpRequest();
    xhttp.onload = function() {
        docs_data = JSON.parse(this.responseText)['docs'];
        draw_docs();
    }
    url = build_url_from_form_entries('/json/docs');
    console.log('load_docs url='+url);
    xhttp.open("GET", url);
    xhttp.send();

}

////////////////////////////////////////////////////////////////////////////////
// render data
////////////////////////////////////////////////////////////////////////////////

function plotly_redraw(newPlot=false) {

    var trace_count = {
      hovermode: 'closest',
      hovertemplate: '',
      type: 'scattergl',
      line: {
        shape: 'hv',
        color: '#55f',
        width: 1,
      },
      marker: {
        size: 1,
      },
    };

    var trace_count_lo = Object.assign({}, trace_count);
    trace_count_lo.line = {
        hovermode: false,
        hovertemplate: false,
        shape: 'hv',
        color: '#ccf',
        width: 1,
      };

    var trace_count_hi = Object.assign({}, trace_count_lo);

    if (count_data) {
        trace_count.x = count_data['xs'];
        trace_count.y = count_data['term_counts'];
        trace_count_lo.x = count_data['xs'];
        trace_count_lo.y = count_data['term_counts_lo'];
        trace_count_hi.x = count_data['xs'];
        trace_count_hi.y = count_data['term_counts_hi'];
    }
    else {
        trace_count.x = ['1960-01-01 00:00:00', '2022-01-01 00:00:00'];
        trace_count.y = [null, null];
        trace_count_lo.x = ['1960-01-01 00:00:00', '2022-01-01 00:00:00'];
        trace_count_lo.y = [null, null];
        trace_count_hi.x = ['1960-01-01 00:00:00', '2022-01-01 00:00:00'];
        trace_count_hi.y = [null, null];
    }

    var trace_projection_dots = {
      xaxis: 'x2',
      yaxis: 'y2',
      type: 'scattergl',
      hoverinfo: 'skip',
      line: {
        shape: 'hv',
        color: '#55f',
        width: 1,
      },
      mode: 'markers',
    }

    var trace_projection_ave = {
      xaxis: 'x2',
      yaxis: 'y2',
      type: 'scattergl',
      hoverinfo: 'closest',
      line: {
        shape: 'spline',
        color: '#55f',
        width: 1,
      },
      marker: {
        size: 1,
      },
    };

    if (projection_data) {
        trace_projection_dots.x = projection_data['xs'];
        trace_projection_dots.y = projection_data['projections'];
        trace_projection_dots.marker = {
            size: 2+2*Math.max(0,1-projection_data['dots']/10000)+2*Math.max(0,1-projection_data['dots']/100),
            color: '#ccf',
        };
        trace_projection_ave.x = projection_data['xs'];
        trace_projection_ave.y = moving_average([],projection_data['projections'].slice(0,projection_data['counts'].length),window_size,projection_data['counts']);
    }
    else {
        trace_projection_dots.x = ['1960-01-01 00:00:00', '2022-01-01 00:00:00'];
        trace_projection_dots.y = [null, null];
        trace_projection_ave.x = ['1960-01-01 00:00:00', '2022-01-01 00:00:00'];
        trace_projection_ave.y = [null, null];
    }

    var data = [trace_count_lo, trace_count_hi, trace_count, trace_projection_dots, trace_projection_ave];

    var layout = {
        grid: {rows: 2, columns: 1},
        showlegend: false,
        margin:{
            l:60,
            r:0,
            t:0,
            b:0,
            pad:0,
        },
        xaxis: {
            autorange: true,
            rangeselector: {
              buttons: [
                {
                  count: 1,
                  label: '1y',
                  step: 'year',
                  stepmode: 'backward'
                },
                {
                  count: 10,
                  label: '10y',
                  step: 'year',
                  stepmode: 'backward'
                },
                {
                  count: 100,
                  label: '100y',
                  step: 'year',
                  stepmode: 'backward'
                },
                {step: 'all'}
              ]},
            //rangeslider: {},
            type: 'date'
        },
        xaxis2: {
          matches: 'x',
        },
        yaxis: {
          fixedrange: true,
          rangemode: 'tozero',
          title: {
            text: 'count',
            font: {
              family: 'Courier New, monospace',
              size: 18,
              color: '#7f7f7f'
            }
          }
        },
        yaxis2: {
          fixedrange: true,
          rangemode: 'tozero',
          title: {
            text: 'projection',
            font: {
              family: 'Courier New, monospace',
              size: 18,
              color: '#7f7f7f'
            }
          }
        }
    };

    if (newPlot) {
        Plotly.newPlot('plotly', data, layout, {displaylogo: false});
        console.log('plotly_redraw(true)');
    }
    else {
        Plotly.react('plotly', data, layout, {displaylogo: false});
        console.log('plotly_redraw(false)');
    }
};
function draw_docs() {
    docs = document.getElementById('docs');
    innerHTML = '';
    for (let i=0; i<docs_data.length; i++) {
        doc = docs_data[i];
        innerHTML += `
        <div class=result>
            <div class=result_host>
                <!--<img src=https://{result.host}}/favicon.ico height=12px width=12px />-->
                ${doc['date_published']} --
                <!-- {result.accessed_at}} -- -->
                <a href='/host/${doc['host']}'>${doc['host']}</a>
                ${doc['rank']}
                &nbsp;
                &nbsp;
                &nbsp;
                id=${doc['id']}
            </div>
            <div class=result_title><a href="/metahtml?url=${doc['url']}">${doc['title']}</a></div>
            <div class=result_description>${doc['description']}</div>
        </div>
        `;
    }
    docs.innerHTML = innerHTML;
}

////////////////////////////////////////////////////////////////////////////////
// utils
////////////////////////////////////////////////////////////////////////////////

function add_randoms(projection_data_raw, max_points=10000.0) {
    let randoms = [];
    let xs = [];
    let total_elements = projection_data_raw['counts'].reduce((a, b) => a + b, 0);
    let total_randoms = Math.min(max_points,total_elements);
    let xs_index = 0;
    let randoms_at_index = 0;
    let stddev = calc_stddev(projection_data_raw['projections']);

    for (var i=0; i<total_randoms && xs_index <projection_data_raw['xs'].length; i++) {
        randoms_at_index += 1
        if (randoms_at_index > projection_data_raw['counts'][xs_index]/total_elements*total_randoms) {
            xs_index += 1;
            randoms_at_index = 0;
            i -= 1;
        }
        else {
            if (projection_data_raw['projections'][xs_index] !== null) {
                xs.push(projection_data_raw['xs'][xs_index])
                // FIXME:
                // this uses the Box-Muller transform to convert two uniform random variables into two normal random variables;
                // the current implementation is 2x slower than it could be since we discard one of the normal random variables
                let r1 = Math.random();
                let r2 = Math.random();
                let random = stddev * Math.sqrt(-2*Math.log(r1))*Math.cos(2*Math.PI*r2);
                randoms.push(projection_data_raw['projections'][xs_index]+random);
            }
        }
    }
    var projection_data = {
        'xs' : projection_data_raw['xs'].concat(xs),
        'projections' : projection_data_raw['projections'].concat(randoms),
        'counts' : projection_data_raw['counts'],
        };

    projection_data['dots'] = 0;
    for (let i=0; i<projection_data['projections'].length; i++) {
        if (projection_data['projections'][i]) {
            projection_data['dots'] += 1;
        }
    }
    return projection_data;
}


function build_url_from_form_entries(url, form_entries) {
    elems = document.getElementById('form_search').elements;
    for (let i=0; i<elems.length; i++) {
        if (elems[i].name) {
            if (elems[i].type != 'checkbox' || elems[i].checked) {
                value = document.getElementById('form_search').elements[elems[i].name].value;
                url = updateURLParameter(url, elems[i].name, value);
            }
        }
    }
    return url;
}


////////////////////////////////////////////////////////////////////////////////
// on page load
////////////////////////////////////////////////////////////////////////////////

plotly_redraw(true);
load_all_data();

// set all form elements to load data on change
elems = document.getElementById('form_search').elements;
for (let i=0; i<elems.length; i++) {
    if (elems[i].name) {
        elems[i].addEventListener('change', load_all_data);
    }
}


</script>
{% endblock %}
